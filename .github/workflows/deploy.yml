name: Deploy Backend to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # 수동 실행 허용

# 동시 실행 제한 - 이전 배포가 진행 중이면 취소하고 새로운 배포 시작
concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production  # 이 설정이 queued 상태를 유발할 수 있음

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Validate secrets
      run: |
        echo "Validating required secrets..."
        if [ -z "${{ secrets.EC2_HOST }}" ]; then
          echo "❌ EC2_HOST secret is not set!"
          exit 1
        fi
        if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
          echo "❌ EC2_SSH_KEY secret is not set!"
          exit 1
        fi
        echo "✅ All required secrets are configured"

    - name: Prepare files for deployment
      run: |
        # 배포용 임시 디렉토리 생성
        mkdir -p deploy-files
        # 필요한 파일만 복사 (venv, .git, .next 등 제외)
        rsync -av --exclude='venv/' \
                  --exclude='__pycache__/' \
                  --exclude='*.pyc' \
                  --exclude='*.log' \
                  --exclude='.DS_Store' \
                  --exclude='node_modules/' \
                  --exclude='.env' \
                  --exclude='*.sqlite3' \
                  --exclude='db.sqlite3' \
                  --exclude='server_new.log' \
                  --exclude='.next/' \
                  --exclude='deploy-files/' \
                  ./ deploy-files/
        echo "✅ Files prepared for deployment"
        du -sh deploy-files/
        # 디렉토리 내용 확인
        echo "📁 Deploy files structure:"
        ls -la deploy-files/ | head -20
        
    - name: Copy files to EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        source: "deploy-files/*"
        target: "~/dungji-market-backend"
        rm: true
        strip_components: 1
        timeout: 120s
        command_timeout: 5m

    - name: Upload .env to EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # ENV_FILE이 설정되어 있으면 업데이트, 아니면 기존 파일 유지
          if [ ! -z "${{ secrets.ENV_FILE }}" ]; then
            echo "${{ secrets.ENV_FILE }}" > ~/dungji-market-backend/.env
          else
            echo "Using existing .env file on server"
          fi

          # Firebase 서비스 계정 키를 .env에 추가 (Base64 디코딩)
          if [ -n "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
            echo "" >> ~/dungji-market-backend/.env
            echo "FIREBASE_SERVICE_ACCOUNT=$(echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' | base64 -d)" >> ~/dungji-market-backend/.env
            echo "✅ Firebase credentials added to .env"
          fi

    - name: Deploy application
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        timeout: 60s
        command_timeout: 30m
        script: |
          set -e  # Exit on any error
          
          echo "🚀 Starting deployment process..."
          cd ~/dungji-market-backend
          
          # 배포 전 상태 확인
          echo "🔍 Pre-deployment check..."
          echo "Current containers:"
          sudo docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
          echo "Port 8000 usage:"
          sudo lsof -i :8000 || echo "Port 8000 is free"
          echo ""

          # 필수 파일 확인
          if [ ! -f .env ]; then
            echo "❌ ERROR: .env file not found!"
            echo "Please create .env file on the server first."
            echo "Refer to DEPLOYMENT.md for configuration details."
            exit 1
          fi
          echo "✅ Environment file found"
          
          if [ ! -f docker-compose.yml ]; then
            echo "❌ ERROR: docker-compose.yml file not found!"
            exit 1
          fi
          echo "✅ Docker Compose file found"
          
          # 🔥 Nuclear cleanup: PID 레벨에서 강제 정리
          echo "🔥 Nuclear cleanup: Killing container processes at PID level..."

          # 모든 dungji 관련 컨테이너의 PID 찾아서 kill
          for container_id in $(sudo docker ps -aq --filter "name=dungji"); do
            if [ ! -z "$container_id" ]; then
              echo "Found container: $container_id"
              PID=$(sudo docker inspect -f '{{.State.Pid}}' "$container_id" 2>/dev/null || echo "")
              if [ ! -z "$PID" ] && [ "$PID" != "0" ]; then
                echo "Killing PID $PID for container $container_id"
                sudo kill -9 "$PID" 2>/dev/null || echo "PID already dead"
              fi
            fi
          done

          # Docker system prune으로 완전 정리 (좀비 컨테이너 포함)
          echo "🧹 Running docker system prune (removing ALL stopped containers, networks, images)..."
          sudo docker system prune --all --force --volumes || true

          # 최종 확인
          echo "📊 Remaining containers after cleanup:"
          sudo docker ps -a

          # 디스크 사용량 확인
          echo "💾 Disk usage after cleanup:"
          df -h / | head -2

          # 포트 8000 최종 확인 및 강제 해제
          echo "🔍 Checking port 8000..."
          if sudo lsof -i :8000 2>/dev/null; then
            echo "⚠️  Port 8000 still in use, force killing..."
            sudo fuser -k 8000/tcp || true
            sleep 2
          fi

          # 최종 포트 확인
          if sudo lsof -i :8000 2>/dev/null; then
            echo "❌ ERROR: Port 8000 is still in use after all cleanup attempts!"
            sudo lsof -i :8000
            exit 1
          else
            echo "✅ Port 8000 is now available"
          fi
          
          # 새 이미지 빌드 및 컨테이너 시작
          echo "🏗️  Building and starting containers..."
          # container_name이 지정되어 있으므로 일관된 이름 사용
          sudo docker-compose up --build -d --force-recreate --remove-orphans

          # 컨테이너 시작 대기
          echo "⏳ Waiting for containers to be ready..."
          sleep 10

          # 컨테이너 상태 확인
          echo "📊 Checking container status..."
          sudo docker ps --filter "name=dungji-backend-web"

          # 웹 서비스 확인
          echo "🔍 Checking web service..."
          if sudo docker ps --filter "name=dungji-backend-web" --filter "status=running" | grep -q dungji-backend-web; then
            echo "✅ Web container is running"
          else
            echo "❌ Web container is not running"
            sudo docker logs dungji-backend-web
            exit 1
          fi

          # 마이그레이션 실행
          echo "🔄 Running database migrations..."
          sudo docker exec dungji-backend-web python manage.py migrate --noinput

          # 정적 파일 수집
          echo "📦 Collecting static files..."
          sudo docker exec dungji-backend-web python manage.py collectstatic --noinput

          # 최종 상태 확인
          echo "🏥 Final health check..."
          sudo docker ps --filter "name=dungji-backend-web"

          # 로그 출력
          echo "📋 Recent application logs:"
          sudo docker logs --tail=20 dungji-backend-web
          
          # 간단한 API 테스트 (빠른 확인)
          echo "🧪 Testing API endpoint..."
          sleep 5
          if curl -f -s http://localhost:8000/api/health/ > /dev/null 2>&1; then
            echo "✅ API health check passed"
          else
            echo "⚠️  API health check failed (will continue)"
          fi
          
          echo "🎉 Deployment completed successfully!"
          echo "📝 Application is running at: http://${{ secrets.EC2_HOST }}:8000"