name: Deploy Backend to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # 수동 실행 허용

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production  # GitHub Environment 사용 (선택사항)

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Validate secrets
      run: |
        echo "Validating required secrets..."
        if [ -z "${{ secrets.EC2_HOST }}" ]; then
          echo "❌ EC2_HOST secret is not set!"
          exit 1
        fi
        if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
          echo "❌ EC2_SSH_KEY secret is not set!"
          exit 1
        fi
        echo "✅ All required secrets are configured"

    - name: Copy files to EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        source: "."
        target: "~/dungji-market-backend"
        rm: true
        strip_components: 0
        timeout: 60s
        command_timeout: 15m

    - name: Upload .env to EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "${{ secrets.ENV_FILE }}" > ~/dungji-market-backend/.env

    - name: Deploy application
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        timeout: 60s
        command_timeout: 15m
        script: |
          set -e  # Exit on any error
          
          echo "🚀 Starting deployment process..."
          cd ~/dungji-market-backend
          
          # 포트 8000을 사용하는 프로세스 종료
          echo "🔍 Checking for processes using port 8000..."
          
          # 문제가 있는 특정 컨테이너 처리
          if sudo docker ps -a | grep -q "580c0a899188"; then
            echo "⚠️  Found problematic container 580c0a899188"
            echo "Attempting to resolve..."
            
            # Docker 서비스 재시작
            sudo systemctl restart docker || true
            sleep 5
            
            # 컨테이너 강제 제거 시도
            sudo docker rm -f 580c0a899188 || true
            
            # 여전히 존재하면 Docker 런타임 파일 직접 제거
            if sudo docker ps -a | grep -q "580c0a899188"; then
              echo "Direct removal of container runtime files..."
              sudo systemctl stop docker
              sudo rm -rf /var/lib/docker/containers/580c0a899188*
              sudo systemctl start docker
              sleep 5
            fi
          fi
          
          # 모든 Docker 컨테이너 중지 (포트 충돌 방지)
          echo "Stopping all Docker containers that might use port 8000..."
          sudo docker ps -q | xargs -r sudo docker stop || true
          
          # 모든 종료된 컨테이너 제거
          echo "Removing all stopped containers..."
          sudo docker container prune -f || true
          
          # netstat으로 포트 확인
          echo "Checking port usage with netstat..."
          sudo netstat -tlnp | grep :8000 || true
          
          # lsof로 포트 확인
          if sudo lsof -i :8000; then
            echo "🛑 Port 8000 is in use. Force killing processes..."
            sudo lsof -ti:8000 | xargs -r sudo kill -9 || true
            sleep 5
          fi
          
          # fuser로 추가 확인
          sudo fuser -k 8000/tcp || true
          sleep 2
          
          # 최종 확인
          if sudo lsof -i :8000; then
            echo "❌ ERROR: Port 8000 is still in use after cleanup!"
            sudo lsof -i :8000
            exit 1
          else
            echo "✅ Port 8000 is now available"
          fi

          # 필수 파일 확인
          if [ ! -f .env ]; then
            echo "❌ ERROR: .env file not found!"
            echo "Please create .env file on the server first."
            echo "Refer to DEPLOYMENT.md for configuration details."
            exit 1
          fi
          echo "✅ Environment file found"
          
          if [ ! -f docker-compose.yml ]; then
            echo "❌ ERROR: docker-compose.yml file not found!"
            exit 1
          fi
          echo "✅ Docker Compose file found"
          
          # 기존 컨테이너 중지 및 정리
          echo "🛑 Stopping existing containers..."
          # docker-compose down이 실패할 수 있으므로 개별적으로 처리
          sudo docker-compose stop || true
          sudo docker-compose rm -f || true
          sudo docker-compose down --remove-orphans || true
          
          # 모든 관련 컨테이너 강제 정리
          echo "🧹 Cleaning up any remaining containers..."
          # sudo를 사용하여 권한 문제 해결
          sudo docker ps -a | grep dungji-market-backend | awk '{print $1}' | xargs -r sudo docker stop || true
          sudo docker ps -a | grep dungji-market-backend | awk '{print $1}' | xargs -r sudo docker rm -f || true
          
          # 특정 문제가 있는 컨테이너 강제 제거
          echo "🧹 Force removing stuck containers..."
          
          # 포트 8000을 사용하는 프로세스 강제 종료
          echo "Killing processes using port 8000..."
          sudo fuser -k 8000/tcp || true
          
          # Docker 프로세스 확인 및 종료
          echo "Checking for docker-proxy processes..."
          sudo pkill -f "docker-proxy.*:8000" || true
          sleep 2
          
          # 문제가 있는 컨테이너 ID 확인
          STUCK_CONTAINERS=$(sudo docker ps -a | grep -E "(dungji|8000|580c0a899188)" | awk '{print $1}')
          if [ ! -z "$STUCK_CONTAINERS" ]; then
            echo "Found stuck containers: $STUCK_CONTAINERS"
            
            # Docker 데몬 재시작
            echo "Restarting Docker daemon..."
            sudo systemctl restart docker
            sleep 10
            
            # 재시작 후 강제 제거
            for container in $STUCK_CONTAINERS; do
              echo "Force removing container: $container"
              sudo docker rm -f $container || true
            done
          fi
          
          # 모든 dungji 관련 컨테이너 최종 정리
          sudo docker ps -a | grep -E "(dungji|8000)" | awk '{print $1}' | xargs -r sudo docker rm -f || true
          
          # Docker 네트워크 정리
          echo "🧹 Cleaning up Docker networks..."
          sudo docker network ls | grep dungji-market-backend | awk '{print $2}' | xargs -r sudo docker network rm || true
          
          # 사용하지 않는 Docker 리소스 정리
          echo "🧹 Cleaning up unused Docker resources..."
          sudo docker system prune -f || true
          
          # 포트 8000이 여전히 사용 중인지 최종 확인
          if sudo lsof -i :8000 2>/dev/null; then
            echo "⚠️  Port 8000 is still in use. Using alternative approach..."
            # 컨테이너를 다른 포트로 실행하는 대안
            export HOST_PORT=8001
            echo "Using alternative port $HOST_PORT"
          else
            export HOST_PORT=8000
          fi
          
          # 새 이미지 빌드 및 컨테이너 시작
          echo "🏗️  Building and starting containers..."
          # 타임스탬프를 사용하여 고유한 프로젝트 이름 생성 (충돌 방지)
          PROJECT_NAME="dungji-backend-$(date +%s)"
          echo "Using project name: $PROJECT_NAME"
          export PROJECT_NAME
          sudo docker-compose -p $PROJECT_NAME up --build -d --force-recreate --remove-orphans
          
          # 컨테이너 시작 대기
          echo "⏳ Waiting for containers to be ready..."
          sleep 30
          
          # 컨테이너 상태 확인
          echo "📊 Checking container status..."
          sudo docker-compose -p $PROJECT_NAME ps
          
          # 웹 서비스가 준비될 때까지 대기
          echo "🔍 Waiting for web service to be ready..."
          WEB_READY=false
          for i in {1..30}; do
            if sudo docker-compose -p $PROJECT_NAME ps | grep -q "web.*Up"; then
              echo "✅ Web container is running"
              if sudo docker-compose -p $PROJECT_NAME exec -T web python manage.py check --deploy 2>/dev/null; then
                echo "✅ Web service is ready"
                WEB_READY=true
                break
              fi
            fi
            echo "Attempt $i/30: Web service not ready yet, waiting..."
            sleep 10
          done
          
          if [ "$WEB_READY" = false ]; then
            echo "❌ Web service failed to start within timeout"
            echo "Container logs:"
            sudo docker-compose -p $PROJECT_NAME logs web
            exit 1
          fi
          
          # 마이그레이션 실행
          echo "🔄 Running database migrations..."
          sudo docker-compose -p $PROJECT_NAME exec -T web python manage.py migrate --noinput
          
          # 정적 파일 수집
          echo "📦 Collecting static files..."
          sudo docker-compose -p $PROJECT_NAME exec -T web python manage.py collectstatic --noinput
          
          # 최종 상태 확인
          echo "🏥 Final health check..."
          sudo docker-compose -p $PROJECT_NAME ps
          
          # 로그 출력
          echo "📋 Recent application logs:"
          sudo docker-compose -p $PROJECT_NAME logs --tail=20 web
          
          # 간단한 API 테스트
          echo "🧪 Testing API endpoint..."
          API_HEALTHY=false
          # 사용된 포트 확인
          ACTUAL_PORT=$(sudo docker-compose -p $PROJECT_NAME ps | grep web | grep -oP '0.0.0.0:\K[0-9]+' | head -1)
          if [ -z "$ACTUAL_PORT" ]; then
            ACTUAL_PORT=8000
          fi
          echo "Testing on port: $ACTUAL_PORT"
          
          for i in {1..10}; do
            if curl -f -s http://localhost:$ACTUAL_PORT/api/health/ > /dev/null 2>&1; then
              echo "✅ API health check passed"
              API_HEALTHY=true
              break
            fi
            echo "API check attempt $i/10: waiting..."
            sleep 3
          done
          
          if [ "$API_HEALTHY" = false ]; then
            echo "⚠️  API health check failed after multiple attempts"
            echo "This might indicate the application is not fully ready"
          fi
          
          echo "🎉 Deployment completed successfully!"
          echo "📝 Application is running at: http://${{ secrets.EC2_HOST }}:$ACTUAL_PORT"